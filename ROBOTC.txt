#pragma config(Sensor, S1,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     touchSensor,    sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const tSensors touchSensor = (tSensors) S2; //tells robotc what to look for a touch sensor on port 2

//declare all functions
void bumper (void);
void straight(void);
void straight2(void);
void turn(void);

task main()
{
	nMotorPIDSpeedCtrl[motorC]=mtrSpeedReg;     //using PID in order to adjust the power provided to the motors in case ..
	nMotorPIDSpeedCtrl[motorB]=mtrSpeedReg;     //.. of friction or sudden stop to maintain the same speed of both motors


	//declare variables
	int max = 1000;
	int min = 100;
	int speed;


	// setting up a random speed at the start of the program
	// always makes the robot move forward, keeps the number positive , regarding its actual sign
	speed = abs((rand() % (max-min)) + min); //
 	motor[motorB] = speed;

	//call functions
	straight();

	bumper();

	turn();

	straight();

	bumper();

	turn();

	straight();

	bumper();

	turn();

	straight();

	bumper();

	turn();

	straight2();

}//End main()

//implement functions
	void straight()
{
	 /*using motor synchronization to maintain and define their
            speed relative to each other, to make the motors move in
            a straight line eg, pause/wait or stop
        */

	//this time set slave motor to 0, so that it stays in place while master motor is still performing its function in order to make a left turn
	//setting master motor speed to 50


	nSyncedMotors=synchBC;
	nSyncedTurnRatio=100;

	motor[motorC] = 100;
	motor[motorB] = 100;


	wait1Msec(1000);
}//end straight()

	void bumper()
{
	/*while loop executes the condition in the brackets
	any number of times if the condition is true, and will end when the
	condition is false
	ie. when touch sensor bumps into objective it will
	turn from 0 to 1 , therefore it will stop executing
	*/
	while(SensorValue(touchSensor) == 0)
	{
		//moves forward until the condition is true
		motor[motorC] = 100;
		motor[motorB] = 100;

		wait1Msec(100);
	}
	//moves backwards after it bumps off the wall
	motor[motorC] = -75;
	motor[motorB] = -75;

	wait1Msec(500);
}

void turn()
{


	nSyncedMotors=synchBC;
	nSyncedTurnRatio=0; //this time set slave motor to 0, so that it stays in place while master motor is still performing its function in order to make a left turn
	motor[motorB]=50;   //setting master motor speed to 50

	wait1Msec(800);     //allow the function to run for .7 sec
}//end turn()


void straight2()
{
	nSyncedMotors=synchBC;
	nSyncedTurnRatio=100;

	motor[motorB] = 50;
	motor[motorC] = 50;

	wait1Msec(100);
}//end straight2()
